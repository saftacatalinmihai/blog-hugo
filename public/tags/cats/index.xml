<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Cats - Tag - </title>
        <link>http://localhost:8080/tags/cats/</link>
        <description>Cats - Tag - </description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>saftacatalinmihai@gmail.com (Safta Catalin Mihai)</managingEditor>
            <webMaster>saftacatalinmihai@gmail.com (Safta Catalin Mihai)</webMaster><lastBuildDate>Sat, 07 Jan 2023 13:39:16 &#43;0200</lastBuildDate><atom:link href="http://localhost:8080/tags/cats/" rel="self" type="application/rss+xml" /><item>
    <title>Designing idempotent Streaming system</title>
    <link>http://localhost:8080/posts/akka-graph-dsl-bypass-pattern/</link>
    <pubDate>Sat, 07 Jan 2023 13:39:16 &#43;0200</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/akka-graph-dsl-bypass-pattern/</guid>
    <description><![CDATA[When working with Akka Streams, you might find yourself in a situation where you need to bypass a stage in the graph.
This is a good pattern if we want the whole stream to be idempotent. If we get the same message again, we want the stream to be able to process it - but only the stages that were not already processed.
We usually save the extra information after each processing stage.]]></description>
</item>
<item>
    <title>Pure Functional Stream processing in Scala [2]</title>
    <link>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-2/</link>
    <pubDate>Sun, 14 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-2/</guid>
    <description><![CDATA[In the last post, we saw how to combine pure functions running in IO and Akka streams using .mapAsync and .unsafeToFuture
val source: Source[String, NotUsed] = ??? val sink: Sink[Int, NotUsed] = ??? def pureFunction[F[_]](s: String): F[Int] = ??? source .mapAsync(parallelism = 8)(m =&gt; pureFunction[IO](m).unsafeToFuture()) .runWith(sink) In order to make it easier to work with IO in Akka Streams, we can write some helpers to add a method on Streams that automatically run the IO inside the flow.]]></description>
</item>
<item>
    <title>Pure Functional Stream processing in Scala [1]</title>
    <link>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-1/</link>
    <pubDate>Sat, 06 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-1/</guid>
    <description><![CDATA[In Scala you can write pure functional code, similar to Haskell or other pure functional languages, but you’re not obligated to. Wikipedia categories Scala as an impure Functional language.
FP purists view this as a weakness of Scala, but others view the option of “cheating” pureness as an acceptable choice sometimes. Even if you can do everything purely, it’s sometimes a lot easier to think about the problem in a different paradigm.]]></description>
</item>
</channel>
</rss>
