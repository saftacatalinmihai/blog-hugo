<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Scala - Tag - </title>
        <link>http://localhost:8080/tags/scala/</link>
        <description>Scala - Tag - </description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>saftacatalinmihai@gmail.com (Safta Catalin Mihai)</managingEditor>
            <webMaster>saftacatalinmihai@gmail.com (Safta Catalin Mihai)</webMaster><lastBuildDate>Wed, 10 Jul 2024 12:44:58 &#43;0000</lastBuildDate><atom:link href="http://localhost:8080/tags/scala/" rel="self" type="application/rss+xml" /><item>
    <title>Visual Stream Processing System</title>
    <link>http://localhost:8080/posts/vsps/</link>
    <pubDate>Wed, 10 Jul 2024 12:44:58 &#43;0000</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/vsps/</guid>
    <description><![CDATA[Add I&rsquo;ve added a new tldraw tool called Stream Component (left-most icon: &lt;/&gt; in the toolbar, shortcut key S). You can click or draw a rectangle to add a stream component to the canvas.
The component is not initialized at first - you need to select the component type from the drop-down menu. This UI will be improved to allow more discoverability, show descriptions of components, etc.
After selecting the component type, it will be initialized (started in the backend) and begin running immediately, waiting for inputs on its input port(s).]]></description>
</item>
<item>
    <title>Designing idempotent Streaming system</title>
    <link>http://localhost:8080/posts/akka-graph-dsl-bypass-pattern/</link>
    <pubDate>Sat, 07 Jan 2023 13:39:16 &#43;0200</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/akka-graph-dsl-bypass-pattern/</guid>
    <description><![CDATA[When working with Akka Streams, you might find yourself in a situation where you need to bypass a stage in the graph.
This is a good pattern if we want the whole stream to be idempotent. If we get the same message again, we want the stream to be able to process it - but only the stages that were not already processed.
We usually save the extra information after each processing stage.]]></description>
</item>
<item>
    <title>Pure Functional Stream processing in Scala [2]</title>
    <link>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-2/</link>
    <pubDate>Sun, 14 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-2/</guid>
    <description><![CDATA[In the last post, we saw how to combine pure functions running in IO and Akka streams using .mapAsync and .unsafeToFuture
val source: Source[String, NotUsed] = ??? val sink: Sink[Int, NotUsed] = ??? def pureFunction[F[_]](s: String): F[Int] = ??? source .mapAsync(parallelism = 8)(m =&gt; pureFunction[IO](m).unsafeToFuture()) .runWith(sink) In order to make it easier to work with IO in Akka Streams, we can write some helpers to add a method on Streams that automatically run the IO inside the flow.]]></description>
</item>
<item>
    <title>Pure Functional Stream processing in Scala [1]</title>
    <link>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-1/</link>
    <pubDate>Sat, 06 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>Safta Catalin Mihai</author>
    <guid>http://localhost:8080/posts/pure-functional-stream-processing-in-scala-1/</guid>
    <description><![CDATA[In Scala you can write pure functional code, similar to Haskell or other pure functional languages, but you’re not obligated to. Wikipedia categories Scala as an impure Functional language.
FP purists view this as a weakness of Scala, but others view the option of “cheating” pureness as an acceptable choice sometimes. Even if you can do everything purely, it’s sometimes a lot easier to think about the problem in a different paradigm.]]></description>
</item>
</channel>
</rss>
